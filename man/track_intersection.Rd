% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/track_intersection.R
\name{track_intersection}
\alias{track_intersection}
\title{Calculate intersection metrics in tracks}
\usage{
track_intersection(
  data,
  test = NULL,
  sim = NULL,
  origin.permutation = NULL,
  custom.coord = NULL
)
}
\arguments{
\item{data}{A 'track' R object, which is a list consisting of two elements:
\itemize{
\item \strong{Trajectories}: A list of interpolated trajectories, where each trajectory is a series of midpoints between consecutive footprints.
\item \strong{Footprints}: A list of data frames containing footprint coordinates, metadata (e.g., image reference, ID), and a marker indicating whether the footprint is actual or inferred.
}}

\item{test}{Logical; if \code{TRUE}, the function compares the observed DTW distances against. Default is \code{FALSE}.}

\item{sim}{A 'track simulation' R object consisting of a list of simulated trajectories to use for comparison when \code{test = TRUE}.}

\item{origin.permutation}{A character string specifying the method for permutation of the coordinates of the simulated trajectories' origins.
Options include "None", "Min.Box", "Conv.Hull", or "Custom". Default is "None".}

\item{custom.coord}{A matrix of custom coordinates that define the vertices of an area for permutation of the coordinates of the simulated
trajectories' origins.}
}
\value{
A 'track intersection' R object consisting of a list containing the following elements:
\item{Intersection_metric}{A matrix of unique intersection counts between trajectories. Each entry
represents the number of unique intersection points between the corresponding pair of trajectories.}
\item{Intersection_metric_p_values}{(If \code{test = TRUE}) A matrix of p-values associated with
the intersection metrics, calculated through permutations of simulated trajectory origins. Each entry
reflects the probability of observing an intersection count as extreme as the observed one,
given the null hypothesis of no difference.}
\item{Intersection_metric_p_values_combined}{(If \code{test = TRUE}) A numeric value representing
the combined p-value for all intersections, indicating the overall significance of the
intersection metrics across all pairs of trajectories.}
\item{Intersection_metric_simulations}{(If \code{test = TRUE}) A list containing matrices of
intersection counts for each simulation iteration, allowing for further inspection of the
distribution of intersections across multiple randomized scenarios.}
}
\description{
\code{track_intersection()} calculates the number of unique intersections between trajectories.
The function also supports testing with simulations and different permutation procedures for the coordinates
of the simulated trajectories' origins to compute p-values. This allows for a robust assessment of the intersection metrics,
enabling users to evaluate the significance of the observed intersections in relation to simulated trajectories.
}
\details{
The \code{track_intersection()} function calculates the number of unique intersections between trajectories.
The function also provides options for conducting hypothesis testing through simulated data with permutations of simulated
trajectory origins, enabling the calculation of p-values to evaluate the significance of observed intersections.

The \code{origin.permutation} parameter determines whether any permutation will occur for the simulated trajectories
and specifies the method used to permute the starting coordinates of these trajectories. The available options
include \code{"None"}, which indicates that no permutation will be applied, allowing the function to compute
intersections based solely on the simulated trajectories starting at the same coordinates as the original data.
The \code{"Min.Box"} option conducts permutation within the minimum bounding box surrounding the original
coordinates of origin. Alternatively, the \code{"Conv.Hull"} option utilizes the convex hull around the original
coordinates of origin to perform permutations. Lastly, the \code{"Custom"} option allows for permutation based
on user-defined coordinates that delimit a specific area of interest, as specified in the \code{custom.coord} parameter.
The \code{custom.coord} parameter must be a matrix specifying custom coordinates representing the vertices of the desired area,
effectively constraining the random placement of trajectory origins to this defined region.

Intersections between trajectories can provide valuable insights into (palaeo)ethological behaviors,
such as group movement or hunting dynamics. In cases of side-by-side movement, like a group walking
in parallel or a hunting pack, fewer intersections in the actual data  would be expected compared to random
scenarios, as coordinated movements reduce the likelihood of trajectories crossing. Similarly,
in a chasing or hunting scene or queuing, where one trackmaker is moving ahead of the other, the paths may intersect more frequently than
random movement would predict, leading to an increase in intersections. In both cases, significant similarity metrics may also emerge,
as these structured, non-random movement patterns deviate considerably from those in random simulations. Therefore, combining results
from intersection counts and similarity metrics from \code{simil_DTW_metric()} and \code{simil_Frechet_metric()} functions might be advisable
when testing specific behavioral hypotheses.

The application of permutation to the origins of simulated trajectories, and the method selected, depends on the hypothesis being tested.
If the objective is to determine how many intersections should be expected when trackmakers originate from specific points,
and compare this to the actual data, the origin points should be constrained by the original coordinates, making the \code{"None"}
option the most appropriate. Conversely, if the hypothesis involves testing how many intersections would occur if trackmakers
passed through a broader or defined area, the \code{"Min.Box"}, \code{"Conv.Hull"}, or \code{"Custom"} options are more suitable.

The choice of permutation method also relies on available information about the spatial region where tracks might have been recorded.
For example, the \code{"Min.Box"} or \code{"Conv.Hull"} methods may be employed when there is a defined region that reflects
the likely constraints of where trackmakers left their traces. The \code{"Custom"} option is particularly useful when there is specific
knowledge of the area (e.g., terrain features or environmental conditions) and permutations need to be restricted or excluded from certain zones.

Ultimately, the selection of an appropriate permutation method (or none at all) should align with the behavioral assumptions
underlying the hypothesis—whether testing for gregarism, parallel movement, hunting strategies, or random movement—and
how these behaviors are expected to manifest in the number of intersections observed in both the actual and simulated datasets.
}
\section{Logo}{

\if{html}{\figure{Logo.png}{options: width=30\%}}
}

\examples{
# Example 1: Simulating tracks and comparing intersection metrics in the PaluxyRiver dataset.
# No origin permutation is applied ("None").
s1 <- simulate_track(PaluxyRiver, nsim = 1000, model = "Directed")
int1 <- track_intersection(PaluxyRiver, test = TRUE, sim = s1, origin.permutation = "None")
print(int1)

# Example 2: Simulating tracks and comparing intersection metrics in the PaluxyRiver dataset.
# The origin permutation is applied using the minimum bounding box ("Min.Box").
s2 <- simulate_track(PaluxyRiver, nsim = 1000, model = "Constrained")
int2 <- track_intersection(PaluxyRiver, test = TRUE, sim = s2, origin.permutation = "Min.Box")
print(int2)

# Example 3: Simulating tracks and comparing intersection metrics in the PaluxyRiver dataset.
# The origin permutation is applied using the convex hull ("Conv.Hull").
s3 <- simulate_track(PaluxyRiver, nsim = 1000, model = "Unconstrained")
int3 <- track_intersection(PaluxyRiver, test = TRUE, sim = s3, origin.permutation = "Conv.Hull")
print(int3)

# Example 4: Simulating tracks and comparing intersection metrics in a subsample of the MoutTom dataset.
# The "Min.Box" origin permutation is applied.
sbMountTom <- subset_track(MountTom, tracks = c(1, 2, 3, 4, 7, 8, 9, 13, 15, 16, 18))
s4 <- simulate_track(sbMountTom, nsim = 1000)
int4 <- track_intersection(sbMountTom, test = TRUE, sim = s4, origin.permutation = "Min.Box")
print(int4)

# Example 5: Simulating tracks and comparing intersection metrics in a subsample of the MoutTom dataset.
# The origin permutation is customized ("Custom") using predefined coordinates.
sbMountTom <- subset_track(MountTom, tracks = c(1, 2, 3, 4, 7, 8, 9, 13, 15, 16, 18))
s5 <- simulate_track(sbMountTom, nsim = 1000)
area_origin <- matrix(c(50, 5,
                        10, 5,
                        10, 20,
                        50, 20),
                      ncol = 2, byrow = TRUE)
int5 <- track_intersection(sbMountTom, test = TRUE, sim = s5, origin.permutation = "Custom", custom.coord = area_origin)
print(int5)

}
\seealso{
\code{\link{tps_to_track}}, \code{\link{simulate_track}}, \code{\link{simil_DTW_metric}}, \code{\link{simil_Frechet_metric}}
}
\author{
Humberto G. Ferrón

humberto.ferron@uv.es

Macroevolution and Functional Morphology Research Group (www.macrofun.es)

Cavanilles Institute of Biodiversity and Evolutionary Biology

Calle Catedrático José Beltrán Martínez, nº 2

46980 Paterna - Valencia - Spain

Phone: +34 (9635) 44477
}
